#summary TODO list

= Priority Scheduling =
   # When a thread is added to the ready list that has a higher priority than the currently running thread, the current thread should immediately yield the processor to the new thread. DONE
   # When threads are waiting for a lock, semaphore, or condition variable, the highest priority waiting thread should be awakened first. DONE, THOUGH no test captures.
   # A thread may raise or lower its own priority at any time, but lowering its priority such that it no longer has the highest priority must cause it to immediately yield the CPU.
   # Implement priority donation: H to "donate" its priority to L while L is holding the lock, then recall the donation once L releases (and thus H acquires) the lock.
   # Be sure to handle multiple donations, in which multiple priorities are donated to a single thread. You must also handle nested donation: if H is waiting on a lock that M holds and M is waiting on a lock that L holds, then both M and L should be boosted to H's priority. If necessary, you may impose a reasonable limit on depth of nested priority donation, such as 8 levels.
   # You must implement priority donation for locks. You need not implement priority donation for the other Pintos synchronization constructs. You do need to implement priority scheduling in all cases.
   # Implement thread_set_priority: Sets the current thread's priority to new_priority. If the current thread no longer has the highest priority, yields.
   # Implement thread_get_priority: Returns the current thread's priority. In the presence of priority donation, returns the higher (donated) priority.
   * You need not provide any interface to allow a thread to directly modify other threads' priorities.

   * *priority queue*: list.c/h has sorting and insert-in-order functions, so it can be used as a priority queue, but it is not as efficient as a heap.

= QUESTIONS =
   # timer_interrupt correct place to handle waiting thread while loop?
      - What's too big?
   # does interrupt handler run to completion?
   # priority queue implementation available?
   # thread_block/unblock() vs semaphore
      - why are synchronization primitives preferred?

= ABOUT SEMAPHORES =
   * sema_down pushes the calling thread to the waiting threads list and thread_blocks it.
   * sema_up pops the calling thread from the waiting threads list and thread_unblocks it.
   * thread_unblock, instead of resuming right to the unblocked process, pushes it into the ready queue, just like thread_yield is doing.
      * I called thread_yield after sema_up to push the thread into the ready queue; I'm guessing this was redundant.
      * This may mean that using thread_block/unblock() is the same as using semaphores, it's just implemented at a higher level.
      * sema_up()ing doesn't resume right into the corresponding thread. I guess the scheduler just picks it up after it's been pushed into the ready list.

= PROJECT BUGS =
   # priority scheduling: is the problem because we are using the same _elem_ element for both semaphore waiter list and ready list? 